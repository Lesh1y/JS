/*
1. Для практикума из занятия 7 продумать, где можно применить замыкания.
Функции, создающие функции; Привязка данных, сохраняющихся между вызывами функции;
Инкапсуляция (Один из примеров ее использования мы можем увидеть в исходном
коде библиотеки jQuery, которая окружает замыканием весь свой код, чтобы не
выводить за его пределы нужные только ей переменные);

2. Не выполняя кода, ответить, что выведет браузер и почему.
во всех алёртах лежат переменные без вызыва функции.
    if (!("a" in window)) {
        var a = 1;
    }
    alert(a);

Так как браузер проходит по коду два раза, a = функции:
"a() {
    alert(this);
}"
Таким образом, блок if не выполняется, а alert возвращает саму функцию в том виде,
в котором она указана выше.

var b = function a(x) {
    x && a(--x);
};
alert(a);
Тут мы присваиваем переменной b функцию a с аргументом x, в теле которой выполняем
ту же функцию а с аргументом --x (префиксный декремент x) в случае, если x = true.
alert всё так же выводит функцию a, объявленную в самом конце.

function a(x) {
    return x * 2;
}
var a;
alert(a);
поскольку a уже определена, alert также выведет функцию. В памяти лежит последнее
объявление a, поэтому текущее будет проигнорировано. Функция вызывается в одном месте,
а её тело может быть описано где угодно, таким образом в a лежит последнее объявленное
тело функции.

function b(x, y, a) {
    arguments[2] = 10;
    alert(a);
}
Здесь мы определяем функцию b с тремя аргументами, в теле которой третьему аргументу
присваиваем значение 10 и вызываем alert(a), однако, функцию мы не вызвали, значит и
alert не срабатывает. Но при отдельном вызове этой функции он вывел бы 10, что
бы мы не передали в функцию.

b(1, 2, 3);
так как переменная b была инициализирована, вызывается именно та функция, что в ней лежит:
function a(x) {
    x && a(--x);

function a() {
    alert(this);
}
a.call(null);
Последнее объявление функции a, которое остаётся в памяти. typeof(null) показывает object,
хотя null это самостоятельный тип данных, в данном случае его, получается, можно передать,
как параметр в call(object), но, так как это все же не объект, мы передали НИЧЕГО,
поэтому this не меняется, а выводит глобальный объект window.
*/
